<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <title>Three.js Realistic Heartbeat</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
    }
  </style>
</head>

<body>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- 1. 场景初始化 ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x110505); // 深血红色背景
    scene.fog = new THREE.Fog(0x110505, 2, 10);   // 增加一点迷雾营造氛围

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 1, 4);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.toneMapping = THREE.ReinhardToneMapping; // 色调映射，看起来更真实
    renderer.toneMappingExposure = 1.5;
    document.body.appendChild(renderer.domElement);

    // --- 2. 灯光设置 (关键：营造血肉质感) ---
    const ambientLight = new THREE.AmbientLight(0x404040, 2); // 环境光
    scene.add(ambientLight);

    // 主光源 - 模拟手术灯或聚光灯
    const spotLight = new THREE.SpotLight(0xffffff, 10);
    spotLight.position.set(2, 5, 5);
    spotLight.angle = Math.PI / 6;
    spotLight.penumbra = 0.5;
    spotLight.castShadow = true;
    scene.add(spotLight);

    // 红色轮廓光 - 增加体积感
    const rimLight = new THREE.PointLight(0xff0000, 5, 10);
    rimLight.position.set(-2, 1, -2);
    scene.add(rimLight);

    // --- 3. 加载心脏模型 ---
    let heartMesh = null;
    const loader = new GLTFLoader();

    // !!! 注意：请将此处替换为你下载的实际模型路径 !!!
    // 推荐模型搜索关键词: "Realistic Human Heart" on Sketchfab
    loader.load('path/to/your/heart_model.glb', (gltf) => {
      heartMesh = gltf.scene;

      // 调整模型大小和位置
      heartMesh.scale.set(1, 1, 1);
      heartMesh.position.set(0, -0.5, 0);

      // 遍历模型子网格，优化材质
      heartMesh.traverse((child) => {
        if (child.isMesh) {
          // 如果模型自带纹理，保留它，但调整物理属性
          // 如果没有纹理，这里给一个基础的血肉颜色
          if (!child.material.map) {
            child.material.color.setHex(0x8a0b0b);
          }

          // 关键：高光泽度模拟湿润的组织
          child.material.roughness = 0.3; // 越低越光滑湿润
          child.material.metalness = 0.1; // 少量金属感模拟光泽

          // 如果想更真实，可以使用 MeshPhysicalMaterial 开启次表面散射 (SSS)
          // child.material = new THREE.MeshPhysicalMaterial({
          //     color: 0x8a0b0b,
          //     roughness: 0.3,
          //     metalness: 0.1,
          //     clearcoat: 1.0,       // 表面粘液层
          //     clearcoatRoughness: 0.1,
          //     normalMap: child.material.normalMap // 保留原有法线
          // });

          child.castShadow = true;
          child.receiveShadow = true;
        }
      });

      scene.add(heartMesh);
    }, undefined, (error) => {
      console.error('模型加载失败，请检查路径', error);
    });

    // 辅助控制器
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // --- 4. 心跳动画逻辑 (模拟 Lub-Dub 节奏) ---
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const time = clock.getElapsedTime();

      if (heartMesh) {
        // 心跳算法：结合正弦波和指数函数来模拟急促的收缩
        // 频率: 1.2 (大约每分钟 72 次)
        const beatSpeed = 3;

        // 使用 Math.pow(Math.sin) 让波形更尖锐，模拟肌肉瞬间收缩
        // 这是一个简化的模拟，也可以使用更复杂的 Shader 顶点位移
        const beat = Math.pow(Math.sin(time * beatSpeed), 10);

        // 定义收缩幅度 (比如放大 10%)
        const scaleFactor = 1 + beat * 0.08;

        // 应用缩放
        heartMesh.scale.set(scaleFactor, scaleFactor, scaleFactor);

        // 添加轻微的旋转，让它看起来是悬浮在液体中
        heartMesh.rotation.y = Math.sin(time * 0.5) * 0.1;
      }

      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    // 窗口自适应
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>

</html>